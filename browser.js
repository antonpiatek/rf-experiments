;(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module '"+r+"'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){// Generated by CoffeeScript 1.5.0

/*
This file is to be ran on the browser.
*/


(function() {
  var LightwaveRF, dataEl, formEl, output, outputEl;

  LightwaveRF = require('./lightwaverf.coffee');

  formEl = null;

  outputEl = null;

  dataEl = null;

  output = function(results) {
    var html, lastData, outputRepeats, repeatCount, result, _i, _len, _ref;
    html = "";
    lastData = null;
    repeatCount = 0;
    outputRepeats = function() {
      if (repeatCount > 0) {
        html += "Repeats: <span class='data'>" + repeatCount + "</span><br />";
      }
      repeatCount = 0;
      if (lastData != null) {
        return html += "</div>";
      }
    };
    for (_i = 0, _len = results.length; _i < _len; _i++) {
      result = results[_i];
      if (result.valid) {
        if (lastData === result.data) {
          repeatCount++;
        } else {
          outputRepeats();
          lastData = result.data;
          html += "<div class='entry'>";
          html += "<tt>" + result.pretty + "</tt> <span class='debug'>from " + result.startIndex + ".." + result.stopIndex + "</span><br />";
          html += "Remote: <span class='data'>" + result.remoteId + "</span>, subunit: <span class='data'>" + result.subunit + "</span> <span class='debug'>(" + result.subunitName + ")</span>, command: <span class='data'>" + result.command + "</span> <span class='debug'>(" + result.commandName + ")</span>, parameter: <span class='data'>" + result.parameter + "</span> <span class='debug'>(" + ((_ref = result.level) != null ? _ref : "-") + ")</span><br />";
        }
      }
    }
    outputRepeats();
    return outputEl.innerHTML = html;
  };

  window.addEventListener('DOMContentLoaded', function() {
    formEl = document.getElementById('input');
    outputEl = document.getElementById('output');
    dataEl = document.getElementById('data');
    return formEl.onsubmit = function(e) {
      var data, results;
      e.preventDefault();
      data = dataEl.value.replace(/[^0-9,]/, "");
      data = data.split(",");
      results = LightwaveRF.decode(data);
      console.log(results);
      output(results);
      return false;
    };
  });

}).call(this);

},{"./lightwaverf.coffee":2}],2:[function(require,module,exports){// Generated by CoffeeScript 1.5.0

/*
LightwaveRF by @Benjie
*/


(function() {
  var DURATION_HIGH, DURATION_ONE, DURATION_TEN, ERROR_MARGIN, TRANSMISSION_GAP, commandNames, commands, decodeLightwaveRF, k, v, withinErrorMargin;

  TRANSMISSION_GAP = 10250;

  DURATION_TEN = 1250;

  DURATION_ONE = 250;

  DURATION_HIGH = 250;

  ERROR_MARGIN = 150;

  commands = {
    OFF: 0,
    ON: 1,
    MOOD: 2
  };

  commandNames = [];

  for (k in commands) {
    v = commands[k];
    commandNames[v] = k;
  }

  withinErrorMargin = function(val, expected) {
    var margin;
    margin = ERROR_MARGIN + expected / 8;
    return (expected - margin < val && val < expected + margin);
  };

  /*
  `analogReads` is an array of durations in us (microseconds).
  
  If the data you pass has been divided by a divisor (e.g. 40) then pass this
  divisor via the `options` hash, e.g. `options.divisor=40`
  */


  decodeLightwaveRF = function(analogReads, options) {
    var bits, byte, divisor, endData, i, id, index, isHigh, l, letter, nibble, nibbleLookup, nibbles, number, result, results, sensibleData, startData, startIndex, stopIndex, str, subunitNameLookup, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref;
    if (options == null) {
      options = {};
    }
    divisor = options.divisor;
    if (divisor == null) {
      divisor = 1;
    }
    results = [];
    sensibleData = false;
    isHigh = false;
    bits = null;
    startIndex = null;
    stopIndex = null;
    endData = function(index) {
      var binStr, data, pretty, raw;
      stopIndex = index;
      sensibleData = false;
      binStr = bits.join("");
      if (binStr.length < 8) {
        return;
      }
      raw = binStr;
      pretty = raw.substr(0, 1) + " " + raw.substr(1).replace(/1(....)(....)/g, " 1  $1 $2 ");
      data = raw.substr(1).replace(/1(........)/g, "$1");
      return results.push({
        startIndex: startIndex,
        stopIndex: stopIndex,
        raw: raw,
        pretty: pretty,
        data: data
      });
    };
    startData = function(index) {
      startIndex = index;
      sensibleData = true;
      isHigh = true;
      return bits = [];
    };
    for (index = _i = 0, _len = analogReads.length; _i < _len; index = ++_i) {
      l = analogReads[index];
      l *= divisor;
      if (sensibleData) {
        if (isHigh) {
          if (l > DURATION_HIGH + ERROR_MARGIN) {
            isHigh = false;
          }
        }
        if (!isHigh) {
          if (withinErrorMargin(l, DURATION_ONE)) {
            bits.push("1");
          } else if (withinErrorMargin(l, DURATION_TEN)) {
            bits.push("10");
          } else {
            endData(index);
          }
        }
        isHigh = !isHigh;
      }
      if (!sensibleData) {
        if (withinErrorMargin(l, TRANSMISSION_GAP)) {
          startData(index);
        }
      }
    }
    nibbleLookup = ["11110110", "11101110", "11101101", "11101011", "11011110", "11011101", "11011011", "10111110", "10111101", "10111011", "10110111", "01111110", "01111101", "01111011", "01110111", "01101111"];
    subunitNameLookup = [];
    _ref = "ABCD".split("");
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      letter = _ref[_j];
      for (number = _k = 1; _k <= 4; number = ++_k) {
        subunitNameLookup.push(letter + number);
      }
    }
    for (_l = 0, _len2 = results.length; _l < _len2; _l++) {
      result = results[_l];
      str = result.data;
      nibbles = [];
      while (str.length >= 8) {
        byte = str.substr(0, 8);
        str = str.substr(8);
        nibble = nibbleLookup.indexOf(byte);
        if (nibble < 0) {
          break;
        }
        nibbles.push(nibble);
      }
      result.nibbles = nibbles;
      if (nibbles.length >= 10) {
        result.valid = true;
        result.parameter = nibbles[0] << 4 + nibbles[1];
        if (result.parameter >= 0x80) {
          result.level = result.parameter - 0x80;
        }
        result.subunit = nibbles[2];
        result.subunitName = subunitNameLookup[nibbles[2]];
        result.command = nibbles[3];
        result.commandName = commandNames[nibbles[3]];
        id = 0;
        for (i = _m = 0; _m <= 5; i = ++_m) {
          id += nibbles[4 + i] << (4 * (5 - i));
        }
        result.remoteIdInt = id;
        result.remoteId = "0x" + id.toString(16).toUpperCase();
      }
    }
    return results;
  };

  exports.decode = decodeLightwaveRF;

  exports.commands = commands;

  exports.commandNames = commandNames;

}).call(this);

},{}]},{},[1]);